# Модельно-Оринтированная Архитектура

В предыдущих главах подчеркивалась важность подхода к разработке ПО, которая сосредоточена вокруг предметной области бизнеса. Мы говорили, что критически важно создать модель, которая основывается на предметной области и отражает ее ключевые концепции с высокой точность. Универсальный язык следует использовать на протяжении всего процесса моделирования, для того, чтобы способствовать общению между командой разработки и экспертами домена, а так же чтобы выявить ключевые концепции домена, которые должны быть использованы в модели. Цель процесса моделирования - создать качественную модель. Следующий шаг - имплементация модели в коде. Это столь же важная фаза процесса разработки ПО. Создав отличную модель, но неудачно перенеся ее в код, вы получите программное обеспечение сомнительного качества.

Может так случиться, что аналитики работают с экспертами предметной области месяцами, выясняют ключевые части домена, выражают связи между ними и создают качественную модель, которая точно отражает суть предметной области. Потом модель передается к разработчикам. Они в свою очередь могут выяснить, что некоторые концепции или связи модели не могут быть должным образом выражены в коде. Поэтому они будут использовать модель, как основу для идей, но создадут свой собственный дизайн, который частично позаимствует идеи из модели, а частично будет состоять из заново созданных. Процесс разработки продолжится, будут создаваться новые классы, увеличивая разрыв между оригинальной моделью и итоговой реализацией. Гарантий хорошего конечного результат нет. Хорошие разработчики смогут создать продукт, который работает, но сможет ли он выдержать испытание временем? Будет ли он хорошо расширяемым? А легко поддерживаемым?

Любая предметная облать может быть описана множеством моделей, а каждая модель может быть по-разному выражена в коде. Для каждой конкретной задачи может быть более одного решения. Какое именно стоит выбрать? Не каждая корректная аналитическая модель можеть быть прямо выражена в коде. Или, возможно, ее реалзация нарушит какие-то принципы проектирования приложения, что, конечно же, не очень хорошо. Поэтому важно выбирать модель, которая легко и точно может быть перенесена в код. Значит основной вопрос здесь - как мы переходим от модели к коду?

Одним из рекомендуемых методов проектирования является так называемая модель анализа, которая рассматривается отдельно от разработки кода и обычно выполняется разными людьми. Модель анализа является результатом анализа бизнес-области, в результате чего модель не учитывает программное обеспечение, используемое для реализации. Такая модель используется для понимания предметной области. Построен определенный уровень знаний, и полученная модель может быть аналитически правильной. Программное обеспечение на данном этапе не принимается во внимание, поскольку считается фактором, сбивающим с толку. Эта модель доходит до разработчиков, которые должны заниматься дизайном. Поскольку модель была построена без учета принципов дизайна, она, вероятно, не будет служить этой цели. Разработчикам придется его адаптировать или создать отдельный дизайн. И между моделью и кодом больше нет соответствия. В результате после начала кодирования от моделей анализа вскоре отказываются.

Одна из основных проблем этого подхода в том, что аналитики не могут предвидеть некоторые дефекты в их модели, а так же все тонкости домена. Они могут слишом сильно уйти в детали для одних компонетнтов и наоборот недостаточно осветить другие. Очень важные детали выясняются во время проектирования и реализации. Модель, соответствующая домену, может иметь серьезные проблемы с хранением объектов или неприемлемой производительностью. Разработчики будут вынуждены принимать некоторые решения самостоятельно и делать изменения в архитектуре, чтобы решить реальные проблемы, которые не учитывались, когда создавалась модель. Они создают архитектуру, которая отдаляется от модели, делая ее менее релевантной.

При независимой работе аналитиков, в конечном итоге они создадут модель. Когда она будет передана архитекторам, некоторая часть знаний аналитиков о домене будет потеряна. Хотя модель моожет быть выражена в диаграммах и документах, есть шансы, что архитекторы не поймут весь смысл модели, или отношений между некоторыми объектами, или их поведения. Есть детали модели, которые сложно передать через диаграмму и даже письменно. Разработчики столкнутся со сложностями пытаясь их выяснить. В некоторых случаях они будут делать некоторые предположения о предполагаемом поведении, и возможно такое, что часть из них будет неверна, что станет причиной некорректно работающей программы.

Аналитики встречаются на своих, закрытых, митингах, где обсуждаются многие детали, касающиеся домена и происходит интенсивный обмен знаниями. Они создают модель, которая должна включать в себя всю эту информацию в сжатом виде, а разработчики должны усвоить всю эту информацию, читая предоставленную документацию. Будет гораздо более продуктивно, если разработчики смогут присоединится к встречам аналитиков, и таким образом получить ясное и полное представление о предметной области и модели до того, как начнут работать над архитектурой.

Лучшим подходом является тесно связать моделирование предметной области и разработку архитектуры. Модель должна создаваться с учетом особенностей архитектуры программного обеспечения. Разработчики должны быть включены в процесс моделирования. Основная идеят состоит в выборе модели, которая сможет быть соответствующим образом выражена в коде, так чтобы процесс проектирования (архитектуры) был прозрачным и основывался на модели. Тесная связь кода и модели, на которой он основан придает ему ясность и делает модель релевантной.

Вовлечение разработчиков порождает обратную связь. Это создает уверенность в том, что модель может быть реализована в ПО. Если где-то есть ошибка, то это обнаруживается на более ранней стадии и проблему можно просто решить.

Те, кто пишет код, должны знать модель очень хорошо и чувствовать ответственность за ее целостность. Они должны понимать,  что изменение в коде подразумевает изменение в модели; иначе они модифицируют код до того состояния, когда он больше не будет описывать исходную модель. Если аналитик отделен от процесса реализации, вскоре, он перестанет беспокоиться об ограничениях, привносимых разработкой. Как результат - модель, не имеющая практического применения.

Любой технический специалист, вносящий изменения в модель должен потратить некоторое время на изучение кода, не важно насколько высокую роль он или она играет в проекте. Каждый, ответственный за измненение кода должен научиться выражать модель посредством кода. Каждый разработчик должен участвовать в обсуждении модели на определенном уровне и иметь связь с экспертами предметной области. Те, кто вносит свой вклад другими способами должны сознательно вовлекать тех, кто связан с кодом в динамический процесс обмена идей о модели посредством Универсального Языка.

Если архитектура или какая-то ее важная часть не соответствует модели предметной области, эта модель имеет небольшую ценность и корректнотсь созданного ПО находится под вопросом. В то же время, если связи между моделью и архитектурой есть, но они сложны для понимания, то на практике они окажутся не поддерживаемы. Так, между архитектурой и анализом возникает непреодолимая пропасть, и идеи полученные в любой из эти частей не развивают другую.

Спроектируйте часть системы, чтобы она максимально только отражала модель, так чтобы это отображение было очевидным. Пересмотрите модель и измените так, чтобы она могла быть реализована более естественным образом в коде, даже если вы стремитесь, чтобы она отражала понимание домена более глубоко. Требуйте единую модель, которая соответствует обеим целям, в дополнение к повсеместной поддержке Универсального Языка.

Извлеките из модели терминологию, используемую в архитектуре (и базовое распределение обязанностей). Код должен стать выражением модели, так что изменение кода может быть и изменением модели. Этот эффект должен распространиться и на всю остальную деятельность проекта.

Чтобы тесно связать реализацию и модель, обычно нужны такие инструменты для создания ПО и языки, которые поддерживают парадигму моделирования, например ООП.

ООП подходит для реализации модели, потому что они оба основаны на одной парадигме. ООП предоставляет классы объектов и связи классов, экземпляры объекто и общение между ними. ООП языки делают возможным прямые отображения между объектами модели с их связями, и их аналогами в коде.

Процедурные языки предлагают ограниченную поддержку модельно-ориентированной архитектуры. Таки языки не предлагают конструкций необходимых для имплементации ключевых компонентов модели. Некоторые скажут, что ООП может быть реализовано с помощью процедурного языка Си, действительно, некоторые функции могут быть воспроизведены таким образом. Объекты могут быть представлены как структуры данных (data structures). Таки структуры не содержат поведения объекта, и оно должно быть добавлено отдельно ввиде функций. Эти связи будут существовать только в голове разработчика, потому что код сам по себе не будет явно их выражать. Программа, написанная на процедурном языке обычно представляется как набор функций, вызывающийх одна другую и работающих вместе для достижения определенного результата. Такая программа не может легко инкапсулировать концептуальные связи, что усложнаяет понимание того, как модель связана с кодом.

Некоторые специфичные домены, вроде математики, могут быть легко смоделированы и реализованы используя процедурное программирование, потому что многие математические теории рассматриваются как вызов функций и структуры данных, потому что в основном речь идет о вычислениях. Более сложносоставные области - это не просто набор абстракций, содержащих вычисления и не могут быть сведены к набору алгоритмов, так что процедурные языки не справляются с задачей выражения соответствующий моделей. По этой причине, процедурное программирование не рекомендуется для модельно-ориентированной архитектуры.

## Составляющие Модельно-Ориентированной Архитектуры

Последующие части этой главы расскажут о наиболее важных паттернах модельно-ориентированной архитектуры. Задача этих паттернов представить ключевые элементы объктного моделирования и архитектуры ПО с точки зрения DDD. Диаграмма ниже - это карта паттернов и отношений между ними.
![figure5](./images/figure5.PNG)

### Слоеная Архитектура

![figure6](./images/figure6.PNG)

Когда мы создаем программное приложение, большАя его часть не связана напрямую с доменом, но является частью инфраструктуры или обслуживает само программное обеспечение. Вполне нормально для доменной части приложения быть довольно маленькой по сравнению с остальным, ведь типичное приложение включает в себя много кода, связанного с доступом к базам данных, файлам, сетям, а так же пользовательские интерфейсы и так далее.

В объектно-ориентированной программе, UI, база данных и прочий вспомогательный код обычно пишется напрямую в бизнес-объектах. Дополнительная бизнес-логика встроена в поведение виджетов интерфейса и скрипты базы данных. Иногда это происходит потому что это самый быстрый способ заставить все работать (быстро).

Однако, когда код, связанный с предметной областью смешивается с другими слоями, его становится чрезвычайно сложно читать и осмысливать. Поверхностные изменения интерфейса могут изменить бизнес-логику. Для изменения бизнес-правила, может потребоваться тщательное отслеживание его среди кода UI, базы данных и других элементов приложения. Реализация согласованных, основанных на модели объектов становится непрактичной. Автоматическое тестирование неудобным. Учитывая все разнообразие технологий и логики, задействованных в каждом действии, программа должна оставаться очень простой, иначе ее будет невозможно понять.

Следовательно, нужно разделить сложную программу на СЛОИ. Разрабатывать архитектуру внутри каждого СЛОЯ, который является связным и зависит только от слоев ниже. Следуйте стандартным архитектурным шаблонам, чтобы обеспечить слабую связность со слоями выше. Сконцентрируйте весь код, относящийся к домену в одном слое и изолируйте его от интерфейса пользователя, кода приложения и инфраструктурного кода. Объекты домена, освобожденные от задач отображения самих себя, хранения, управления задачами приложения и так далее, могут быть сосредоточены на выражении доменной модели. Это позволяет модели развиваться и становиться достаточно богатой и чистой, чтобы улавливать ключевые знания о бизнесе и применять их на практике.

Общее арихтектурное решение для предметно-ориентированных архитектур включает четыре концептуальных слоя:

| Название слоя                               | Описание |
| ------------------------------------------- | ----------- |
| **Интерфейс пользователя (слой отображения)** | Отвечает за отображение информации пользователю и интерпретацию комманд пользователя |
| **Слой приложения**                         | Это тонкий слой, который координирует активность приложения. Он не включает бизнес-логику. Не хранит состояние бизнес-объектов, но может хранить состояние задач приложения |
| **Слой предметной области (домена)**          | Этот слой включает информацию о предметной области. Это сердце программного обеспечения. Состояние бизнес-объектов хранится здесь. Сохранность данных бизнес-объектов и возможно их состояние делегируется инфраструктурному слою. |
| **Слой инфраструктуры**                       | Этот слой ведет себя как вспомогательная библиотека для всех остальных слоев. Он предоставляет взаимодействие между слоями, реализовывает сохранность данных бизнес-объектов, влючает вспомогательные библиотеки для слоя отображения и т. д. |

Важно разделять приложение на отдельные слои и устанавливать правила общения между ними. Если код не разделить явно на слои, вскоре он станет настолько запутанным, что будет очень сложно вносить изменения. Одно простое изменение в одной части кода может неожиданно и нежелательно повлиять на другие. Слой предметной области должен быть сфокусирован на вопросах ядра домена. Он не должен быть вовлечен в инфраструктурные задачи. Интерфейс в свою очередь не должен быть ни тесно связан с бизнес логикой, ни задачами, которые обычно присущу инфраструктурному слою. Слой приложения необходим во многих случаях. Там должен находиться менеджер всех действий бизнес-логики, который контролирует и координирует всю активность приложения.

Для примера, типичное взаимодействие приложения, домена и инфраструктуры может выглядеть так. Пользователь хочет забронировать маршрут полета и запрашивает сервис приложения в слое приложения для этого. Слой приложения извлекает соответствующие доменные объекты из инфраструктурного слоя и вызывает необходимые методы для них, например, чтобы проверить безопаность границ остальных уже забронированых перелетов. Как только объекты домена сделали все проверки и обновили свой статус до "решено", сервис приложения сохраняет объекты в инфраструктуре.

### Сущности

Существует категория объектов, которые как представляется должны быть идентифицируемы на протяжении всех стадий существования программного обеспечения. Для этих объектов важны не атрибуты, а нить преемствинности и идентичности, которая охватывает все время жизни системы и может выходить за ее пределы. Такие объекты называются Сущностями.

ООП языки хранят экземпляры объектов в памяти и они привязывают ссылку или адрес в памяти для каждого. Эта ссылка уникальна для каждого экземпляра в конкретный момент времени, но нет гарантии, что так и останется на неограниченном временно промежутке. На саммо деле верно как раз обратное. Объекты постоянно перемещаются в память и из нее, они сериализуются и отправляются по сети и воссоздаются на другом конце или уничтожаются. Эта ссылка, которая вляется уникальной для работающего окружения программы не является не даюет на идентифицируемость, о которой мы говорим. Если у нас есть класс, который хранит информацию о погоде, например температуру, то очень возможно иметь два различных экземпляра этого класса, которые содержат одинаковое значение. Объекты полностью идентичны и взаимозаменяемы, но у них различные ссылки. Они не являются сущностями.

Если бы мы реализовывали представление человека, используя программирование, мы бы возможно создали класс Person, с набором атрибутов: имя, дата рождения, место рождения и т. д. Какой-нибудь из эти атрибутов является идентификатором человека? Имя не может его идентифицировать, потому что могут существовать еще люди с таким же именем. Мы бы не смогли отличить двух людей, если бы принимали во внимание только их имена. Мы не можем так же использовать и их дату рождения, потому что множество людей родилось в тот же день. Это применимо и к месту рождения. Объект должен быть отличим от других объектов даже если у них есть такие же атрибуты. Ошибочная идентификация может привести к повреждению данных.

Представим систему банковских аккаунтов. Каждый из них имеет свой собственный номер. И аккаунт может быть точно идентифицирован этим номером. Такой номер остается неизменным на протяжении всей жизни системы и обеспечивает непрерывность. Номер аккаунта может существовать как объект в памяти, или он может быть уничтожен в памяти и отправлен в базу данных. Он так же может быть заархивирован, когда акканут будет закрыт, но он все еще будет существовать где-то до тех пор, пока представляет какой-то интерес. Не важно как он будет выглядеть, норме останется одинаковым.

Следовательно, реализация сущностей в ПО означает создание уникальности. Для человека это может быть комбинация атрибутов: имя, дата рождения, место рождения, имена родителей, текущий адрес. Номер социального страхования так же используется в США для обеспечения уникальности. Для банковского аккаунта, номер кажется достаточным для идентификации. Обычно идентификатор - это либо атрибут объекта, либо набор атрибутов, возможно специально созданный атрибут для выражения уникальности (, или даже поведение). Важно чтобы система воспринимала объекты с разными идентификаторами как различные и соответственно одинаковыми с идентичными. Если это условие не соблюдается, вся система может быть повреждена.

Существует несколько способов создания уникального идентификатора для каждого объекта. ID может быть автоматически сгенерирован модулем и использован внутри приложения, не делая его видимым пользователю. Он может быть первичным ключом в таблице базы данных, уникальность которого обеспечивает БД. Каждый раз, когда объект извлекается из базы, его идентификатор так же извлекается и воссоздается в памяти. ID может быть создан пользователем, как это происходит с кодами аэропортов. Каждый аэропорт имеет уникальный строковый идентификатор, который известен всему миру и используется тур. агентствами чтобы идентифицировать аэропорты в расписаниях полетов. Еще одно решение, это использовать аттрибуты объекта для создания ID, и когда этого недостаточно, может быть добавлен еще один атрибут, чтобы помочь идентифицировать соответствующий объект.

Когда объет отличим по его идентификатору, а не атрибутам, сделайте так, чтобы таким же образом он идентифицировался в модели. Сохраняйте определение класса простым и сфокусированным на непрерывности и уникальности жизненного цикла. Определите способы, чтобы отличить каждый объект независимо от его формы и истории. Будте внимательны к требованиям, согласно которым необходимо сопоставлять объекты по атрибутам. Определите операцию, которая гарантирует уникальный результат для каждого объекта, возможно с помощью добавления символа, который гарантирует уникальность. Это средство идентификации может быть взято извне, илои это может быть произвольны идентификатор, созданный системой и для системы, но он должен соответствовать условиями идентифицируемости в модели. Модель должна опредетять то, что она значит, чтобы этим являться.

Сущности - важные объекты доменной модели и они должны быть учтены с самого начала процесса моделирования. Так же важно определить нужно ли объекту быть сущностью, обсудим это в описании следующего подхода.

### Объекты-значения

Мы обсудили сущности и важность распознавания сущностей на ранней стадии моделирования. Сущности являются необходимой частью доменной модели. Должны ли все объекты описываться как сущности? Должен ли каждый объект обладать идентификатором?

Нам может хотеться сделать все объекты сущностями. Тогда их можно отслеживать. Но отслеживание и создание идентифицируемости имеет свою цену. Мы должны быть уверенг, что каждый экземпляр уникален и отслеживание уникальности не слишком просто. Решение о том, что сделать идентификатором требует тщательного обдумывания, потому что неверное решение приведет к тому, могут появляться разные объекты с одинаковыми идентификаторами, что нежелательно. Делая все объекты сущностями, так же появляются сложности в производительности. В этом случае для каждого объекта должен быть отдельный экземпляр. Если Customer это объект-сущность, тогда один экземпляр, представляющий конкретного клиента банка, не может быть использован для платежных операций, относящихся к другим клиентам. Как итог - такой экземпляр должен быть создан для каждого клиента. Это может повлечь понижение производительности системы, когда речь идет о тысячах экземпляров.

Давайте представим приложение для рисования. У пользователя есть холст, на котором он может рисовать любые точки, линии любой толщины, стиля и цвета. Было бы полезно создать класс объекта, названного Point, и программа могла бы создать экземпляр такого класса для каждой точки на холсте. Такая точка содержала бы два атрибута связанных с координатами экрана или холста. Необходимо ли рассматривать каждую точку, как имеющую идентификатор? Есть ли в ней преемственность? Кажется, что единственная важная для нее вещь - это координаты.

Есть случаи, когда нужны некоторые атрибуты элемента домена. Нам не интересно что это за объект, только какие у него атрибуты. Объект, который используется чтобы описать определенные аспекты домена, но который не имеет идентификатора называется Объект-значение.

Необходимо провести различие между Объектами-сущностями и Объектами-значениями. Нецелесообразно делать все объекты сущностями ради единообразия. Вообще, рекомендуется выбирать в качестве сущностей только те объекты, которые соответствуют определению сущности. А остальные делать Объектами-значениями. (Мы представим еще один тип объектов в следующем разделе, пока представим, что у нас есть только сущности и значения.) Это упрощает дизнайн и привносит еще некоторые позитивные последствия.

Не имея идентификаторов, Объекты-значения могут легко создаваться и уничтожаться. Никто не заботится о создании идентификатора и сборщик мусора заботится об объекте, когда на него больше никто не ссылается. Это очень упрощает дизайн.

Крайне рекомендуется делать объекты-значения неизменяемыми. Они создаются с помощью их конструктора и никогда не изменяются на протяжении своего существования. Когда вы хотите получить другое значение объекта, вы просто создаете новый. Это имеет важные последствия для дизайна. Будучи неизменяемым, и не имея идентификатора, объект-значение может быть общедоступным. **That can be imperative for some designs.** Из-за общедоступности неизменяемые объекты могут положительно влиять на производительности. Они так же декларируют (manifest) целостность, например, целостность данных. Представьте, что было бы, если бы вы сделали общедоступным изменяемый объект. Система по бронированию воздушных перелетов
